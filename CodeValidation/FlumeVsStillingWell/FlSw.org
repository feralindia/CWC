#+OPTIONS:    H:3 num:nil toc:2 \n:nil @:t ::t |:t ^:{} -:t f:t *:t TeX:t LaTeX:t skip:t d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+PROPERTY: header-args :tangle yes
#+BIBLIOGRAPHY: cwc plain

# to tangle: C-c C-v t
# to remove results: org-babel-remove-result-one-or-many
# to remove specific result block: c-u

#+TITLE: Flume and Velocity Area Comparison
#+AUTHOR:   R.S. Bhalla
#+EMAIL:    bhalla@feralindia.org

#+LANGUAGE:   en
#+STYLE:      <style type="text/css">#outline-container-introduction{ clear:both; }</style>


* Summary

  This documents the code written to test the difference between stream discharges measured using the velocity area method and from flumes.
  Most of the code is borrowed from the CWC project, with the exception of the code for velocity-area measurements which has been rewritten using the simple feature (sf) library and is now based on functions. 

* Libraries

  The following modules are used:

  #+BEGIN_SRC R :exports both :results output
  library(sf)
  library(reshape2)
  library(ggplot2)
  #+END_SRC

  #+RESULTS:
  : Linking to GEOS 3.5.1, GDAL 2.2.2, proj.4 4.9.2, lwgeom 2.3.3 r15473

* Functions

** Import Data

   Import wlr data from raw files (multiple files downloaded from loggers) by merging the files together and formatting the time zone and rename the columns.

   - Input :: Full file names, can also be a list of file names generated by list.files()
   - Output :: Merged dataset

   #+BEGIN_SRC R :exports both :results output
   importdata <- function(flnm){
     x <- do.call("rbind", lapply(flnm, read.csv, skip=8, header=FALSE, strip.white = TRUE, blank.lines.skip = TRUE, stringsAsFactors = FALSE))
     names(x)<- c("scan", "date", "time", "capacitance", "stage")
     x <- x[!is.na(x$date),]
     x$date <- as.Date(x$date, format = "%d/%m/%Y") 
     x <- transform(x, timestamp = paste(date, time, sep=' '))
     x <- x[!is.na(x$date),]
     x$timestamp <- as.POSIXct(x$timestamp, tz = "Asia/Kolkata")
     return(x)
   }
   #+END_SRC

   #+RESULTS[58ea0aa757632cf31e07af6fe4e32fe8b3c6d545]:

** Calibration of capacitance probe

   The probe comprises of two parts: a brass weight which is about 5 cm long and  *shows no capacitance increase* along its length, and a teflon coated wire which shows a linear increase in capacitance as it is submerged. We tested whether it made any difference in the calculation of the stage if we changed the type of model fit to the length of the wire. 

*** getlm

    This uses a linear model to calibrate the capacitance probe. The function does a quick check to see if measurements are entered in cm or metres and ensures the reading are in metres.

    - Input :: Name of file holding the calibration reading.
    - Output :: Summary of model

    #+BEGIN_SRC R :exports both :results output
    getlm <- function(x){
      calibdat <- read.csv(x, header=FALSE, sep=",", col.names=c("stage", "capacitance"), skip=6)
      if(max(calibdat$stage, na.rm = TRUE) > 5) calibdat$stage <- calibdat$stage/100 # convert to meters when calibration is done in cm
      fitlm <- lm(stage ~ capacitance, data = calibdat)
      print(tail(calibdat))
      print(summary(fitlm))
      return(fitlm) 
    }
    #+END_SRC

    #+RESULTS:

*** getlm.brass

    This uses a interaction linear model to calibrate the capacitance probe where the interaction term is the material (brass or teflon).

    - Input :: Name of file holding the calibration reading.
    - Output :: Summary of model
   
    #+BEGIN_SRC R :exports both :results output
    getlm.brass <- function(x){
      calibdat <- read.csv(x, header=FALSE, sep=",", col.names=c("stage", "capacitance"), skip=6)
      if(max(calibdat$stage, na.rm = TRUE) > 5) calibdat$stage <- calibdat$stage/100 # convert to meters when calibration is done in cm
      calibdat$material[calibdat$stage>0.055] <- "Teflon"
      calibdat$material[calibdat$stage<=0.055] <- "Brass"
      fitlm <- lm(stage ~ capacitance*material, data = calibdat)
      cutoff<<-min(calibdat$capacitance[calibdat$material=="Teflon"])
      print(tail(calibdat))
      print(summary(fitlm))
      return(fitlm)
    }
    #+END_SRC

    #+RESULTS:

*** do.wlr.cal

    Calibrate the wlr capacitance to stage using the calibration done.

    - Input :: The results of the ~getlm~ function above and the wlr data imported using the ~importdata~ function.
    - Output :: A stagecalc column with calibrated stage values is added to the wlr data.
    - TBD :: The calibration needs to be done based on dates so that values are updated over the years to account for changes or degradation of the capacitance probes.
	    
     #+BEGIN_SRC R :exports both :results output
     do.wlr.cal <- function(x, y){
       y$stagecalc <- predict(x, y)
       return(y)
     }
     #+END_SRC	     

     #+RESULTS:

** Calculation of discharge for water level recorders placed in stream beds using velocity area method.

*** Intersect and write shapefiles of the cross section

    Intersect the stream cross section (xsec) with rectangles corresponding to the number of sections the stream was divided into for velocity readings (rec) to get the surface area of each of these sections of the stream cross section. Rewrites the matrix of coordinates into a well-known-text file so it can be exported to a shapefile. This function is called by the ~vel.area~ function which follows.

    - Input :: Matrix of coordinates of the rectangle as ~x~ and the number of rectangles the cross section of the stream is split into as ~y~.
    - Output :: ESRI shapefile

    #+BEGIN_SRC R :exports both :results output
    intersect.xsec <- function(x,y){ 
      rec <- list(x)
      rec <- st_polygon(rec)
      int <- st_intersection(xsec, rec)
      int.st <- st_as_sfc(st_as_text(int))
      st_write(int.st, paste0(y, ".shp"), driver = "ESRI Shapefile", delete_dsn= TRUE)
      return(st_area(int))
    }
    #+END_SRC

    #+RESULTS:

*** Do the velocity area calculations to generate a rating curve 

    Calculate the surface area and multiply it by the velocity measurements taken in different sections of the stream. The function reads in the coordinates of the cross section, splits them into sections based on the number of velocity readings taken, calculates their area and multiplies the surface area of each section with the velocity measured to arrive at the ~discharge~ part of the calculation. 

    - Input :: ~x~ is the list of cross section files and ~y~ is the list of velocity measurements. Note: both ~x~ and ~y~ MUST have the same filename.
    - Output :: Shapefiles with names corresponding to the input file names corresponding to the cross section and the three divisions (rectangles) where the velocity was measured.
    - TBD :: This needs to be changed so that only the intersection is plotted.

    #+BEGIN_SRC R :exports both :results output
    vel.area <- function(x, y){    
      if(basename(x)==basename(y)){
        crd <- read.csv(x, header = TRUE, skip = 5)[,-1]
        vel <- read.csv(y, header = TRUE, skip = 5)
        obs.file <- gsub(".csv| ", "", basename(x))
        site <- strsplit(x, split="/")[[1]][5]
        print(paste0(site, ": ", obs.file))
        out.dir.name <- paste0(output.dir, "cx_shapefiles/", site)
        if(!dir.exists(out.dir.name))dir.create(out.dir.name)
        out.nm <- paste0(out.dir.name, "/", obs.file)
        crd <- crd/100 # convert to metres
        if(crd[1,1] != 0 | crd[1,2] != 0) crd <- rbind(c(0,0),crd) ## add row of 0,0 if missing
        crd <- rbind(crd, c(0,0))
        ## crd <- rbind(crd, crd[1,])
        crd[ , 2] <- crd[ , 2]*-1 # covert y values to negative (depth)
        crd.mat <- as.matrix(crd)
        xsec <<- st_polygon(list(crd.mat))
        xsec.st <- st_as_sfc(st_as_text(xsec)) # convert to wkt then sfc
        st_write(xsec.st, paste0(out.nm, "crossec.shp"), driver = "ESRI Shapefile", delete_dsn= TRUE) # write to shapefile        
        ## st_area(xsec)
        plot(xsec)
        divs <- length(unique(gsub("[[:digit:]]", "", vel$Sl.No.))) # number of divisions of xsec
        seg.ln <- max(crd$Length, na.rm = T)
        seg.ht <- min(crd$Depth, na.rm = T)
        bbx <- paste(seq(0, seg.ln, length.out = divs+1), seg.ht, sep = ",")
        cl1 <- seq(0, seg.ln, length.out = divs+1)
        cl2 <- rep(seg.ht,divs+1)
        bbx <- matrix(c(cl1,cl2), nrow=length(cl1))
        st <- seq(1, nrow(bbx)-1, by=1)
        rec <- lapply(st, function(x){
            y <- x+1
            r1 <- bbx[x,]
            r2 <- bbx[y,]
            r3 <- cbind(bbx[y,1], 0)
            r4 <- cbind(bbx[x,1], 0)
            r5 <- bbx[x,]
        return(rbind(r1,r2,r3, r4, r5))
        })
        rec.ln <- paste0(out.nm, "RecNo_",1:length(rec)) # suffix of shapefile
        sx.area <- mapply(intersect.xsec, rec, rec.ln) # export to shapefile   
        vel$secno <- gsub("[[:digit:]]", "", vel$Sl.No.)
        vel <- aggregate(cbind(velR1, velR2, velR3) ~ secno, data=vel, FUN=mean)
        avg.vel <- as.list(apply(vel,1, function(x) mean(as.numeric(x[2:4]))))
        avg.disch <- sum(mapply(prod, sx.area, avg.vel)) # multiply each velocity with each xsec and add
        xsec.depth.m <- seg.ht*-1
        vel.dt <- as.Date(read.csv(y, skip=1,nrows=1, header=F)[,c(2)], format = "%d/%m/%y")
        vel.tm <- read.csv(y, skip=2,nrows=1, header=F)[,c(2)]
        vel.dt.tm <- paste(vel.dt, vel.tm, sep=' ')
        timestamp <- as.POSIXct(vel.dt.tm, format="%Y-%m-%d %I:%M:%S %p", tz="Asia/Kolkata") 
        res.df <- data.frame(site, obs.file, timestamp, avg.disch, xsec.depth.m)
        return(res.df)
	} else {
        print("ERROR: File names differ.")
	}
    }
    #+END_SRC

    #+RESULTS[88d598335e8992d57b918905ce552e38287b488a]:

*** Get the stage of the stream recorder based on time stamp of velocity measurements

     The stage of the water level recorder is then taken from the timestamp on the velocity measurement and used as the ~stage~ part of the calculation. 

     - Input :: ~x~ is the output of the ~vel.area~ function; ~y~ is the calibrated wlr readings at 15 minute intervals. This can be changed to a five minute interval (or any other) if needed.
     - Output :: Stage appended to the stage discharge file which can now be used to calculate the rating curve.

    #+BEGIN_SRC R :exports both :results output
    get.stage <- function(x, y){
      pat <- paste0(y, "_15 min.csv")
      fn <- list.files(path ="~/Res/CWC/Data/Nilgiris/wlr/csv/", pattern = pat, full.names = TRUE )
      wlr <- read.csv(fn)
      x$timestamp <- as.POSIXct(x$timestamp, tz = "Asia/Kolkata")
      wlr$date_time <- as.POSIXct(wlr$date_time, tz = "Asia/Kolkata")
      x$dt.round <- as.POSIXct(round(as.double(x$timestamp)/(15*60))*(15*60),origin=(as.POSIXct('1970-01-01')))
      wlr$dt.round <- as.POSIXct(round(as.double(wlr$date_time)/(15*60))*(15*60),origin=(as.POSIXct('1970-01-01')))
      merged.df <- merge(x, wlr, by = "dt.round")
      merged.df <- merged.df[complete.cases(merged.df),]
      merged.df <- merged.df[,c("site", "obs.file", "timestamp", "avg.disch", "xsec.depth.m", "raw", "cal", "date_time")]
      names(merged.df) <- c("site", "obs.file", "vel.timestamp", "avg.disch", "xsec.depth", "scan", "stage", "wlr.timestamp") 
      return(merged.df)
    }
    #+END_SRC

    #+RESULTS:

*** Calculate discharges using velocity area method

   Calculates discharge based on the nonlinear (weighted) least-squares estimates of the rating data.

   - Input :: Stilling well data processed using the "importdata" function as x and rating curve data calculated using the vel.area function as y.
   - Output :: Discharge values for the wlr data. 

    #+BEGIN_SRC R :exports both :results output
    calc.disch.areastage <- function(x, y){
      sd <- y[,c("stage", "avg.disch")]
      names(sd) <- c("Stage", "Discharge")
      nls.res <- nls(Discharge~p1*Stage^p3, data=sd, start=list(p1=3,p3=5), control = list(maxiter = 500)) # (p1=3,p3=5)
      coef.p1 <- as.numeric(coef(nls.res)[1])
      coef.p3 <- as.numeric(coef(nls.res)[2])
      x <- x[, c("capacitance", "stagecalc", "timestamp")]
      names(x) <- c("Capacitance", "Stage", "Timestamp")
      x$Discharge <- coef.p1*x$Stage^coef.p3
      return(x)
    }
    #+END_SRC

    #+RESULTS:

** Calculation of discharge for flume

*** Fix stage of flume

    The stilling well of the flume is lower than the scale (surface of the flume) by about 6 to 7 cm. This function uses the manual scale readings and compares them to the wlr records following which it adjusts all wlr readings by adding the difference. Note that these values change each time the unit is re-installed and hence this code needs to be re-run each year using the appropriate set of readings.

    - input :: File with manual readings from the stilling well and the flume data with stage calculated.
    - Output :: Adjusted stage in the flume file.

    #+BEGIN_SRC R :exports both :results output
    fix.flume.stage <- function(x, y){
      x$dt.round <- as.POSIXct(round(as.double(x$timestamp)/(15*60))*(15*60),origin=(as.POSIXct('1970-01-01')))
      dat <- read.csv(y)
      dat$Height <- dat$Height/100 # convert to metres
      dat$Timestamp <- as.POSIXct(dat$Timestamp, tz = "Asia/Kolkata", format = "%d/%m/%y %H:%M")
      dat$dt.round <- as.POSIXct(round(as.double(dat$Timestamp)/(15*60))*(15*60),origin=(as.POSIXct('1970-01-01')))
      merged <- merge(dat, x, by = "dt.round")
      merged$stgfix <- merged$stagecalc-merged$Height
      avg.fix <- mean(merged$stgfix, na.rm = TRUE)
      x$stagecalc <- x$stagecalc-avg.fix
      return(x[,-8])
    }    
    #+END_SRC

    #+RESULTS:

*** Calculate discharge for the flume

   Uses the equation here [[https://www.openchannelflow.com/flumes/montana-flumes/discharge-tables][here]] to calculate the discharge from the flume based on the stage readings. Note that all flumes require that the stage is adjusted before this calculation is done using the function ~fix.flume.stage~.

    - Input :: Wlr data for flume generated using the ~importdata~ and applying the linear model using the ~predict~ function or read in from a file.
    - Output :: Discharge values slapped onto the flume data as an additional column.

    #+BEGIN_SRC R :exports both :results output
    calc.disch.flume <- function(x){
      x <- x[,c("capacitance", "stagecalc", "timestamp")]
      names(x) <- c("Capacitance", "Stage", "Timestamp")
      p1 <- 176.5
      p3 <- 1.55
      x$Discharge <- p1*(x$Stage)^p3*0.001 # in m cube per sec
      return(x)
    }
    #+END_SRC

    #+RESULTS:

** Compare data between flume and velocity area method

   Merges the discharge data of the flume and velocity area method using a rounded (fifteen minutes, can be changed) timestamp, plots and generates a data frame for subsequent calculations.

   - Input :: velocity-area based discharge estimates (15 minutes), flume based discharge measurements and names of the output figures.
   - Output :: merged dataframe and ggplot2 based figure in panels corresponding to periods when both data sources have been recording.

       #+BEGIN_SRC R :exports both :results output
       plot.discharges <- function(x, y, nms){
         x$Timestamp <- as.POSIXct(round(as.double(x$Timestamp)/(15*60))*(15*60),origin=(as.POSIXct('1970-01-01')))
	 y$Timestamp <- as.POSIXct(round(as.double(y$Timestamp)/(15*60))*(15*60),origin=(as.POSIXct('1970-01-01')))
	 merged <- merge(x, y, by = "Timestamp")
	 merged$group <- c(0, cumsum(diff(as.Date(merged$Timestamp)) > 1))
	 names(merged) <- c("Timestamp", "Capacitance.sw", "Stage.sw", "Discharge.sw", "Capacitance.fl", "Stage.fl", "Discharge.fl", "Group")
	 ggdat <- melt(merged, value.name = "Discharge", measure.vars = c("Discharge.sw", "Discharge.fl"), id.vars = c("Timestamp", "Group"))
	 ggp <- ggplot(data = ggdat, aes(x = Timestamp, y = Discharge, colour = variable))+
	   facet_wrap(~ Group, scales = "free") +
	   geom_line()
	 print(ggp)
	 ggsave(filename = paste0(output.dir, "discharge/figures/", nms, ".png"), plot = ggp)
	 return(merged)
	}
       #+END_SRC

       #+RESULTS:

* Testing with sample data

  All the relevant data is provided as a zip file. It would be very helpful if manual calculations are used to confirm the script works correctly. I have already done this but may have mucked up the formulae/procedure. Stations 107 (grassland velocity-area) and 110 (grassland flume) are being used.

** Datasets

   1. Check to see if datasets exist, else unzip the data file and create the datasets. Note that for sake of file size, only a sample of the dataset has been provided.

      #+BEGIN_SRC R :exports both :results output
      setwd("./")
      if(!dir.exists("./Data"))unzip("DataSets.zip")
      #+END_SRC

      #+RESULTS:

   2. Define file locations

      #+BEGIN_SRC R :exports both :results output
      input.dir <- "./Data/input/"
      output.dir <- "./Data/output/"
      #+END_SRC

      #+RESULTS:

** Calculate the stage using linear models

   1. Import the data collected by the water level recorders in a list.
      
      #+BEGIN_SRC R :exports both :results output
      in.wlr.dir <- list.dirs(paste0(input.dir, "wlr"), recursive = FALSE)
      in.wlr.files <- lapply(in.wlr.dir, list.files, full.names = TRUE)
      names(in.wlr.files) <- basename(in.wlr.dir)
      stillwell <- lapply(in.wlr.files, importdata)
      head(stillwell[[1]])
      #+END_SRC

      #+RESULTS[84b0774508aeef69bb1c0e6d40a651f21e9e5b92]:
      :   scan       date     time capacitance stage           timestamp
      : 1    1 2013-08-25 15:44:08        2170  2170 2013-08-25 15:44:08
      : 2    2 2013-08-25 15:59:08        2114  2114 2013-08-25 15:59:08
      : 3    3 2013-08-25 16:14:08        2109  2109 2013-08-25 16:14:08
      : 4    4 2013-08-25 16:29:08        2104  2104 2013-08-25 16:29:08
      : 5    5 2013-08-25 16:44:08        2093  2093 2013-08-25 16:44:08
      : 6    6 2013-08-25 16:59:08        2091  2091 2013-08-25 16:59:08

   2. Calibrate the relevant capacitance probes and calculate the stages of the wlr readings.

      #+BEGIN_SRC R :exports both :results value
      in.cal.files <- list.files(paste0(input.dir, "calib"), full.names = TRUE)
      lm.stillwell <- lapply(in.cal.files, getlm)
      names(lm.stillwell) <- basename(in.wlr.dir)
      stillwell <- mapply(do.wlr.cal, lm.stillwell, stillwell, SIMPLIFY = FALSE)
      head(stillwell[[2]])
      #+END_SRC

      #+RESULTS:
      | 1 | 2014-01-09 | 12:10:16 | 879 | 0.14 | 2014-01-09 12:10:16 | 0.222576528211233 |
      | 2 | 2014-01-09 | 12:25:16 | 879 | 0.14 | 2014-01-09 12:25:16 | 0.222576528211233 |
      | 3 | 2014-01-09 | 12:40:16 | 879 | 0.14 | 2014-01-09 12:40:16 | 0.222576528211233 |
      | 4 | 2014-01-09 | 12:55:16 | 878 | 0.14 | 2014-01-09 12:55:16 | 0.221913271309456 |
      | 5 | 2014-01-09 | 13:10:16 | 877 | 0.14 | 2014-01-09 13:10:16 | 0.221250014407679 |
      | 6 | 2014-01-09 | 13:25:16 | 876 | 0.14 | 2014-01-09 13:25:16 | 0.220586757505902 |

** Calculate the discharges

*** For area stage

    1. Define the input data sources. Note that the names of the files in the cross section (xsec) and velocity (vel) folder should be exactly the same. As per convention, these are the dates on which the velocity reading was taken.

       #+BEGIN_SRC R :exports both :results value
       in.xsec.dir <- list.dirs(paste0(input.dir, "xsec"), recursive = FALSE)
       xsec.fls <- lapply(in.xsec.dir, list.files, full.names = TRUE)
       in.vel.dir <- list.dirs(paste0(input.dir, "vel"), recursive = FALSE)
       vel.fls <- lapply(in.vel.dir, list.files, full.names = TRUE)
       xsec.vel.dirs <- data.frame(in.xsec.dir, in.vel.dir , stringsAsFactors = FALSE)
       s.d.pts <- apply(xsec.vel.dirs, 1,  function(x){
         xsec <- lapply(as.character(x["in.xsec.dir"]), list.files, full.names = TRUE)
	 xsec <- unlist(xsec)
	 vel <- lapply(as.character(x["in.vel.dir"]), list.files, full.names = TRUE)
	 vel <- unlist(vel)
	 s.d.pts <- do.call("rbind", mapply(vel.area, xsec, vel, SIMPLIFY = FALSE, USE.NAMES = FALSE))
       return(s.d.pts)
       })
       mapply(function(x, y) write.csv(x, file = paste0(output.dir, "rating/", y, ".csv"), row.names = FALSE),
         x = s.d.pts,
	 y = basename(in.xsec.dir))
      head(s.d.pts[[1]])	 
      #+END_SRC

       #+RESULTS:
       | wlr_107 | 01jun2015  | 2015-06-01 11:14:00 | 0.00712111851851852 |  0.07 |
       | wlr_107 | 01sept2014 | 2014-09-01 11:05:00 |       0.37579109375 | 0.885 |
       | wlr_107 | 02aug2014  | 2014-08-02 11:08:00 |            0.479804 |   0.9 |
       | wlr_107 | 03dec2014  | 2014-12-03 10:35:00 |  0.0179140666666667 |  0.19 |
       | wlr_107 | 03Sep2013  | 2013-09-03 01:54:00 |   0.128821555555556 | 0.273 |
       | wlr_107 | 05sep2015  | 2015-09-05 11:21:00 |  0.0303214755555556 |  0.18 |

    2. Get the stage from the water level recorder based on the timestamp on the stage-discharge calculation above. Calculate the discharge using the area-stage relationship and a non-linear least square fit.

       #+BEGIN_SRC R :exports both :results output
       if(!exists("s.d.pts")) s.d.pts <- lapply(list.files(paste0(output.dir, "rating/"), full.names = TRUE), read.csv)
       names(s.d.pts) <- basename(in.xsec.dir)
       s.d.pts <- mapply(get.stage, s.d.pts, names(s.d.pts), SIMPLIFY = FALSE)
       mapply(function(x, y) write.csv(x, file = paste0(output.dir, "rating/", y, ".csv"), row.names = FALSE),
         x = s.d.pts,
         y = basename(in.xsec.dir))
       if(!exists("s.d.pts")) s.d.pts <- lapply(list.files(paste0(output.dir, "rating/"), full.names = TRUE), read.csv)
       xsec.vel.data <- mapply(calc.disch.areastage, x = stillwell[names(stillwell) %in% names(s.d.pts)], y = s.d.pts, SIMPLIFY = FALSE)
       #+END_SRC

       #+RESULTS:
       : $wlr_107
       : NULL

*** For flume

    Correct the stage calculation for the flume based on an averaged difference between the manual measurements and the logged data on the wlr then calculate the discharge using the equation. The form below allows sequential processing of all flume units using the ~flume.names~.

    #+BEGIN_SRC R :exports both :results output
    flume.names <- c("wlr_110", "wlr_111", "wlr_112", "wlr_113")
    flume.data <- mapply(fix.flume.stage,
      y = list.files(paste0(input.dir, "flume_stage_correction"), full.names = TRUE),
      x = stillwell[names(stillwell) %in% flume.names], SIMPLIFY = FALSE)
    flume.data <- lapply(flume.data, calc.disch.flume)
    #+END_SRC

    #+RESULTS:

** Compare the discharge between flume and velocity area method.    

   Plot a panel of discharges between the velocity area method and flume for periods when both loggers were recording discharges simultaneously and export the data for further analysis.

   #+BEGIN_SRC R :results output graphics :file comparedischarges.png :bg "transparent" :exports both
   nms <- mapply(paste, names(xsec.vel.data), sub(".csv", "", basename(names(flume.data))), sep = "_")
   xsec.val.merged <- mapply(plot.discharges, xsec.vel.data, flume.data, nms)
   head(xsec.val.merged[[1]])
   #+END_SRC

   #+RESULTS:
   [[file:comparedischarges.png]]

 ------

 
 # Local Variables:
 # eval: (setq-local org-babel-default-header-args:R '((:session . "*R*")))
 # End:
 
